[{"uri":"http://docs.ashitaxi.com/features/","title":"Features","tags":[],"description":"","content":"\nAshita comes packed full of various built-in features to greatly enhance a players experience. Complimenting the built-in features, Ashita also offers a feature-rich plugin SDK allowing developers to further enhance the game client. The included core plugin, Addons, also further extends how developers can further extend Ashita via Lua scripting.\nThis page will cover the various features included in Ashita, however it does not include built-in commands.\nPlease refer to the Commands documentation for more details about those.\nSections on this page will include collapsed information sections and screenshots.\nBe sure to expand them for more information and to see example screenshots!\nCommand Line \u0026amp; Graphical Launchers Ashita comes with two methods of launching and injecting itself into the game client.\nThe command line launcher. (ashita-cli.exe) The graphical launcher. (Ashita.exe) The command line launcher (ashita-cli.exe) can be used to quickly and easily launch a selected profile immediately. This is useful for those who run multiple characters and need to get running quickly. This bypasses any additional loading or processing for Ashita that the graphical launcher adds such as its auto-updates.\nThe graphical launcher instead is used for a more complete launching experience. It includes a full configuration editor, the ability to download most addons and plugins available, as well as keep things automatically up to date.\nInjected Hook In order to offer the best level of customizations and features, Ashita operates by being directly injected into the game client process. Doing so gives Ashita direct access to the games functions and memory. This makes things such as function hooking, pointer usage and memory object wrapping much easier and with little to no overhead as an external program would have.\nThis also allows Ashita to take over parts of the client such as the Direct3D device, allowing Ashita to render its own content into/onto the game scene.\nBeing injected also allows Ashita to hook game functions allowing it to further extend things such as adding its own commands or overriding how existing commands function.\nDirect3D Hook By being directly injected into the game client, Ashita hooks onto and fully wraps the games Direct3D device. This allows Ashita to render its own content into/onto the game scene. This also allows blocking various rendering calls (primitives), alter/block/change render states, and loads more graphics pipeline alterations. Ashita makes use of this hooking to allow itself to render additional information, custom fonts/primitives and a full UI system ontop of the game.\nCustom In-Game Fonts / Primitives Ashita contains its own custom built-in font and primitive rendering systems which allow addons and plugins to further expand the information displayed by the game client. These two systems are designed to allow both basic text information to be displayed on-screen but also allow for building custom UI-like elements. (However, this system is not designed or intended to be a full-scale UI renderer.)\nThe current (and older) base font system makes use of Direct3D and GDI directly to render text ontop of the scene. Due to how this system works, fonts may not look as great as they should as the general GDI handling of text does not include more modern features such as proper aliasing, kerning, and more.\nPrimitives are designed to be able to handle two different styles of rendering. The first is just a basic rectangle rendering mode to display boxes, generally behind text to make things easier to see/read. The other is to allow rendering sprites, which enables rendering images to the screen.\nThe font system also includes a custom inline coloring setup, similar to what is used in modern triple-A games, such as World of Warcraft. This allows users to easily make colorful text to help uniquely display various information.\nFor example, you can render some text as blue like this: |cFF0000FF|This is some blue text!|r\nClick to show some screenshots of various font and primitive usages.. The FPS and clock addons displaying some basic text.\nThe recast addon displaying some cooldown timers. Including color changes for timers almost expiring.\nIn-Game UI (ImGui) While the font and primitive systems offer some means of creating custom user interfaces, they lack the ability to make things more contextual and in-depth. Instead, Ashita also includes ImGui to allow developers of addons and plugins to create feature-rich user interfaces. ImGui comes stock with many different control types such as:\nLabels / Text Basic, wrapped, colored, etc. Bulleted Buttons Small, invisible, arrow, etc. Radio Buttons Checkbox Progress Bars Images Combo Boxes List Boxes Drags \u0026amp; Sliders User Input Text Int / Float (Single, double, triple, quad value inputs.) Scalar / ScalarN Color Editors Tree Nodes Selectables Plotting Lines Histograms Menus / Menu Bars Tooltips Popups / Modals Tables Columns Tabs / Tab Bars And more! You can find more information about ImGui here: https://github.com/ocornut/imgui\nClick to show screenshots of ImGui being used.. Blucheck addon used to display BLU spell information.\nMinimap configuration editor used to customize the Minimap plugin.\nRenamer addon used to easily rename entities.\nAmbient Lighting While in certain zones and depending on graphics settings, it can become hard to see various parts of the game world. Ashita comes stock with the ability to alter the games ambient lighting. In most cases, users will just toggle this on and off as needed with the stock white color, however you can set the color hue used with the ambient lighting to your liking as well.\nFill Mode As a fun extra, Ashita also has the ability to change the games current Direct3D fill mode. This is generally used to toggle wireframe mode on and off. This feature can allow you to see through walls, easily target something that may be behind something or otherwise obstructed from your view, etc.\nDirectInput / XInput Hooks Similar to the Direct3D hook, Ashita also hooks onto the DirectInput device and wraps any device creations used for input to the game client. (ie. Keyboard, Mouse, Controller) The keyboard and mouse are hooked and wrapped to allow Ashita to both interact with its own objects (fonts, primitives, ImGui, etc.) but also to allow further extending the devices capabilities, with things such as keybinds.\nFor controllers, Ashita handles both DirectInput and XInput devices, allowing for addons and plugins to take full control of the button presses and overall controller usage.\nKeyboard \u0026amp; Mouse By hooking onto the keyboard and mouse devices, Ashita is able to do a number of useful features.\nHandle input from either device before the game sees it, allowing Ashita to pass the input to its own objects to handle first. (Fonts, Primitives, ImGui, addons/plugins, etc.) Block the input from reaching the game. Inject input not actually done by the user. (ie. Controlling the game externally.) Create custom binds to trigger various functionality when desired buttons or button combinations are pressed. Enable or disable the Windows key on the fly. Plugins can also register to callback events to react to, alter or block input from the keyboard and mouse.\nAshita offers a rich custom keybind system for the keyboard, including modifier keys such as:\n! - Modifier symbol for the ALT key. # - Modifier symbol for the APPS key. ^ - Modifier symbol for the CTRL key. + - Modifier symbol for the SHIFT key. @ - Modifier symbol for the WIN key. For example, you can bind CTRL+ALT+F1 to /wave like this: /bind ^!F1 /wave\nControllers Final Fantasy XI supports both DirectInput and XInput controller devices. Ashita is able to hook onto and handle both of these interfaces. The controller API allows addon and plugin developers to easily monitor for, override and inject controller input easily.\nAshita offers the ability to easily toggle some additional controller features on the fly:\nBackground Controller Usage - Easily toggle if the gamepad should work while the game is out of focus. Disable Gamepad Enumeration - Easily disable the game from trying to find controllers. (This is a useful feature to remove a known stutter issue that DirectInput causes when no gamepad is found.) Hooked Win32 API In order for Ashita to fully function, it must hook several Win32 API that the game makes use of. Some of these are for cosmetic purposes, while others are required to prevent certain issues from happening within the client. Below is a list and quick rundown of each API that is hooked and why:\nd3d8.dll Direct3DCreate8 - Hooked to catch the Direct3D device creation and wrap it. dinput.dll DirectInput8Create - Hooked to catch the DirectInput device creation and wrap it and all created devices. xinput1_3.dll XInputGetState - Hooked to obtain and modify the XInput device gamepad state. advapi32.dll RegQueryValueExA - Hooked to allow Ashita to control the game configurations without relying on the actual registry values. kernel32.dll CreateMutexA/CreateMutexW - Hooked to rename mutex objects to be unique per-Final Fantasy XI instance. OpenMutexA/OpenMutexW - Hooked to rename mutex objects to be unique per-Final Fantasy XI instance. ExitProcess - Hooked to catch unexpected client closes to cleanup Ashita\u0026rsquo;s resources. SetPriorityClass - Hooked to force Final Fantasy XI to always be set to NORMAL_PRIORITY_CLASS. user32.dll CreateWindowExA - Hooked to catch the creation of the Final Fantasy XI window and store / modify its properties. CreateWindowExW - Hooked to catch the creation of the POL window and store / modify its properties. Also catches the creation of the mask windows and forces them to be hidden. GetForegroundWindow - Hooked to fake if Final Fantasy XI is the current foreground window to prevent the client from closing itself under certain window mode conditions. GetFocus - Hooked to fake if Final Fantasy XI is the current foreground window to prevent the client from closing itself under certain window mode conditions. GetSystemMetrics - Hooked to correct the mouse position under certain windowed mode conditions. GetWindowTextA - Hooked to modify the PlayOnline window caption. GetWindowTextW - Hooked to modify the PlayOnline window caption. LoadBitmapW - Hooked to alter the splash screen displayed when PlayOnline is launched. RegisterClassA - Hooked to alter the window icons for any created windows for PlayOnline and Final Fantasy XI. RegisterClassW - Hooked to alter the window icons for any created windows for PlayOnline and Final Fantasy XI. RegisterClassExA - Hooked to alter the window icons for any created windows for PlayOnline and Final Fantasy XI. RegisterClassExW - Hooked to alter the window icons for any created windows for PlayOnline and Final Fantasy XI. RemoveMenu - Hooked to reenable the close window button of the Final Fantasy XI window. SendMessageA - Hooked to alter the window icons for any created windows for PlayOnline and Final Fantasy XI. SetCursorPos - Hooked to prevent the game from snapping the mouse cursor to menus, if desired. SetFocus - Hooked to fake if Final Fantasy XI is the current foreground window to prevent the client from closing itself under certain window mode conditions. SetForegroundWindow - Hooked to fake if Final Fantasy XI is the current foreground window to prevent the client from closing itself under certain window mode conditions. SetWindowsHookExA - Hooked to override the used thread id for input purposes. SetWindowTextA - Hooked to modify the PlayOnline window caption. SetWindowTextW - Hooked to modify the PlayOnline window caption. Hooked Game Functions Similar to hooking Win32 API, Ashita hooks onto several game functions to allow itself to intercept certain information before the game. These include:\n(Chat) CommandCalc - The game function responsible for interpreting and handling commands being processed by the client. (Chat) CTkMsgWinData::AddString - The game function responsible for outputting messages to the chat windows. (Chat) FsWordCompletion::lookUp - The game function responsible for parsing auto-translate words and phrases. (Packets) enAcvGet - The game function responsible for receiving, decrypting and decompressing an incoming packet chunk. (Packets) enAcvSet - The game function responsible for compressing and encrypting an outgoing packet chunk. By hooking onto these functions, Ashita is able to do multiple things to their parameters / data, including:\nRead: See any time the function(s) are called and log, view, or react to the parameters they were called with. Block: Prevent the game client from ever seeing the call was made. Modify: Alter the parameters to change how the call will actually be invoked by the game client. Inject: Manually invoke the original function to easily inject custom data. Click here for an example of how hooks work... To better demonstrate and explain how hooking works, and what benefits it brings, let\u0026rsquo;s take a closer look a the (Chat) CommandCalc function.\nThis function is responsible for processing all commands that are being handled within the client.\nThis function is called anytime the client is handling a command that should be interpreted. This includes things such as:\nThe player first logged in, /servmes is automatically processed and sent to obtain the current server message. The player manually typed in a message or command into the chat window. The player pressed a macro. (Each line of the macro will be sent through this function.) The player selected an option through a menu, such as to attack a target, use a spell, tried to fish, etc. The function looks like this internally:\n1int32_t __cdecl CommandCalc(char* command, uint32_t mode) 2{ 3 // Function body removed for simplicitys sake.. 4 return 0; 5} Each time a command or message is being processed by the client, it will first pass through this function. Once hooked, Ashita will attempt to handle the command first. It does so by passing the function arguments around internally to a few different steps to see if any loaded plugin or addon can handle the command, then finally trying to handle the command itself if nothing else has yet.\nUsing pseudo code, this is how the hook looks once applied:\n1int32_t __cdecl CommandCalc(char* command, uint32_t mode) 2{ 3 // Allow loaded plugins to handle the command first.. 4 if (AshitaCore::instance().m_PluginManager-\u0026gt;HandleCommand(mode, command, false) || 5 AshitaCore::instance().m_PolPluginManager-\u0026gt;HandleCommand(mode, command, false)) 6 return 0; 7 8 // Allow Ashita to handle the command next.. 9 if (AshitaCore::instance().m_ChatManager-\u0026gt;HandleCommand(mode, command, false)) 10 return 0; 11 12 // Allow the game to finally handle the command as normal if nothing else did first.. 13 return Real_CommandCalc(command, mode); 14} Note: Ashita does additional things in this hook, however to keep the pseudo code simple, other code has been removed.\nTo explain the call chain that takes place once the function is hooked, here\u0026rsquo;s a quick rundown.\nAs an example, we\u0026rsquo;ll assume the player typed /wave into the chat input.\nThe player opens the chat input and types the command: /wave The game client invokes the input callback function to handle when input has been entered. The input callback invokes: CommandCalc(\u0026quot;/wave\u0026quot;, 1); The CommandCalc begins execution (executes its prologue code) then jumps to the Ashita hook callback. Ashita begins attempting to handle the command by doing the following: The command is passed to the PluginManager to allow loaded plugins to try and handle the command. If the Addons plugin is loaded, then the command is passed to all loaded addons to allow them to try to handle the command. The command is passed to the PolPluginManager to allow loaded POL plugins to try and handle the command. The command is passed to the ChatManager to allow Ashita to try and handle the command internally. Ashita returns back to the CommandCalc function, which then continues based on the return from Ashita. If Ashita considered the command handled: The rest of the CommandCalc function is skipped, preventing the game from seeing the command. If Ashita considered the command unhandled: The rest of the CommandCalc function is executed, allowing the game to handle the command as normal. The CommandCalc ends execution (executes its epilogue code) and returns. During this entire chain, any loaded plugin (or addon if the Addons plugin is loaded) has the chance to either block or alter the command being handled. For example, if the command being handled is /wave, a plugin could instead tell the game to handle it as /dance. Or, the plugin can out-right block the command from being seen by the game at all.\nAlong with being able to see, block and/or modify the parameters of the function, by hooking the call Ashita also gains the ability to directly call the original function. This allows Ashita to directly inject message/command input to the game. This allows plugins (or addons) to directly inject commands as they see fit, giving the player even more control.\nHooked Function Features While some of the hooks listed above are done to ensure stability and prevent the client from having issues with things such as ALT+Tabbing, some of the hooks are used to implement some cosmetic features.\nVirtualized Registry Settings Final Fantasy XI stores it\u0026rsquo;s client configurations within the Windows system registry. Things such as the games various resolutions, window mode, sound and graphics settings, etc. are stored here. (Generally, anything used at the time of the creation of the game window and devices is stored here. In-game settings are not.) When dualboxing or dual-installing, it is easy to cause bugs or issues with multiple loaders trying to use the same registry settings. To avoid these issues, Ashita virtualizes these settings causing the game client to not actually touch the registry for its settings.\nInstead, the configuration settings that would normally be found in the registry are stored in each boot configuration used to launch Ashita. This allows players to easily configure and customize every configuration differently for all their characters.\nNew with Ashita v4 is a plugin called Sandbox. This plugin fully virtualizes the game client install allowing it to run entirely without being installed. (No registry headaches or DLL registrations at all!)\nCustom Window Icon Ashita replaces the window icons used for both the PlayOnline and Final Fantasy XI windows. This is done to help users easily see which game clients are affected/hooked by Ashita while playing.\nCustom Window Title Ashita replaces the window titles for both the PlayOnline and Final Fantasy XI windows.\nThe PlayOnline window title is changed to include the current Ashita project version that is injected. The Final Fantasy XI window title is changed to the current logged in players name. This makes it very easy to switch between different clients by being able to quickly see which window is taking focus. Log File Fix When Final Fantasy XI was originally designed and then ported to PC, it was designed in a manner that was not dual-box friendly. The game was originally forced into fullscreen mode and trying to ALT+Tab would cause the game to crash. (Fixing this was the original purpose and goal of windowing the game.) However, even though bypassing this limitation is no longer needed as the game supports proper windowed mode itself now, SE never fixed the other shortcomings that happen when trying to run multiple instances of the game.\nOne of those is that the game stores and uses log files on disk to handle the text within the chat windows. When you expand the windows to read the backlog, these log files are referenced to load previous chat output history. If you are dualboxing, then trying to open the chat log can lead to the window output disappearing, becoming corrupt, or completely crashing the game.\nAshita includes a custom patch/fix to create individual folders and log files for each character that is logged in, this way there are no more log conflicts.\nDetailed Logging To help with debugging and other general troubleshooting, Ashita includes a full logging system. Detailed logging information is output to these files found within the /logs/ folder. The output of these files is based on the logging level you have currently set in the loaded boot configuration file.\nConfiguration Files (.ini Backed Files) Ashita includes an optional custom configuration file system that can be used to easily load and save configurations. These configuration files are backed using the well known .ini file format making it easy to read/write values from and to.\nMemory Manager In order to create feature-rich plugins, it is important to be able to access various parts of the game client data. Things such as the local players information like inventory data, current equipment, etc. Ashita includes a MemoryManager object that exposes several frequently accessed memory objects directly to plugins in a manner that helps limit the requirement of recompiling plugins after a major game update. (See plugin info below for more details.)\nPointer \u0026amp; Offset Manager Caching To help with performance, Ashita includes internal pointer and offset managers to cache known information that will not change during the runtime of the client. These are pointers and offsets used to locate important information within the client, such as object pointers to data, function pointers, etc.\nBy using these managers, the values are automatically cached after their first use, making all following usages of the same data instant.\nPointer \u0026amp; Offset Overrides Ashita makes use of .ini configuration files to load its pointer and offset information. Along with these files, there are custom override files that server owners can make use of when using Ashita to version lock to an older client. If that client has a specific different pointer signature for some important data or function, the custom override files can be used to ensure the client will operate properly with Ashita, within reason.\nWhile these files make it possible to keep pointers and offsets proper, it is not possible to realign structures properly. Due to this, it may be impossible to lock to an older client if changes to a structure land up breaking how Ashita would normally function.\nCustom Commands Ashita comes equipped with several useful built-in functionality, mainly focused on controlling the internal aspects of the hook. Additional commands are generally implemented via a plugin or an addon.\nPlease see the full Commands documentation for more information on the built-in commands.\nCustom Scripting (Extended Macros) To assist with the limitations of the games macro system, Ashita includes its own custom text-based scripting engine. These are basic command scripts that you can use to write out much longer macros along with some basic level scripting to control Ashita, plugins, addons and more.\nScripts can be executed via the /exec command.\nScript Arguments New with v4 is the ability to pass arguments to scripts that can be tokenized within a script. This allows players to even further create more in-depth scripts.\nClick here to see an example of using script arguments.. Arguments are handled via tokens. These tokens are formatted as %0% where 0 is the number of the argument to be replaced with.\nFor example, take this script (/scripts/wave.txt):\n/wave %0% And execute it via: /exec wave.txt Atomos\nThis will attempt to wave at an entity named Atomos.\nScript Includes Another new to v4 feature for scripts is the ability to directly include another script. Previously, the only way to do this kind of thing was to execute a second script via /exec within another script. However, this had the downside of none of the commands being executed in any kind of guaranteed order.\nWith v4, scripts now have a preprocessor step that will look for new commands/keywords (such as /include) and rebuild the script on the fly before it is executed. Script execution order is now guaranteed when you make use of the new /include command from within a script.\nClick here to see an example of using script includes.. As demonstrated in the above screenshot, when running scripts directly within another script via /exec the order that commands are executed is not guaranteed. This is because the commands get queued into a thread pool and are executed in any order the pool wishes. However, while using /include, scripts can guarantee the order that commands get executed as the script is rebuilt on the fly via preprocessing before its fully executed.\nFeature-Rich Plugins \u0026amp; Plugins SDK While the main Ashita hook/core is closed source, we offer everyone the ability to help extend the projects capabilities with our open source plugin SDK. The SDK is designed to make development of plugins for Ashita extremely quick and easy, along with helping keep the requirement of maintaining your plugin simple.\nThe Ashita plugin SDK is designed for use with C++ and assumes your compiler will support the latest C++ standard features. While other languages should be able to implement the SDK, the Ashita development team will only give support to those writing plugins in C++\nFor those seeking to implement the SDK in another language, your language will need to support the following:\nThe ability to specifically implement calls as __stdcall calling convention. The ability to properly export unmangled functions from your compiled DLL. The ability to properly implement a C++ style object that properly inherits from the IPlugin object within the SDK. Failure to follow these guidelines will most likely result in your plugin crashing the client!\nOpen Source Our plugin SDK is completely free and open source. Anyone is welcome to write plugins for Ashita!\nBy using the Addons plugin you can also make use of the SDK through the means of Lua based scripting, in the form of addons. (These are basically mini-plugins written in Lua.)\nEasy To Use The plugin SDK is designed to be easy to read, quick to understand, and fast to implement.\nBecause of this and with the use of our example plugin template, you should be able to get a plugin compiled and running within minutes of getting started.\nWe also include several helper headers to make use with in your plugin. These include:\n/d3d8/... - Contains the various Direct3D8 headers and libs used by the Ashita project that plugins may need to compile against. /ffxi/... - Contains Final Fantasy XI related structure definitions for various objects of the games memory. BinaryData.h - Contains helper functions for working with bit level data. (Generally used with packets.) Chat.h - Contains definitions and helper functions for working with Final Fantasy XI\u0026rsquo;s chat window output. Commands.h - Contains helper functions for parsing and working with command arguments. ErrorHandling.h - Contains Ashita\u0026rsquo;s custom exception object and scoped translator helper for catching exceptions easily. ImGuiFontAwesome.h - Contains definitions for using FontAwesome with ImGui. Memory.h - Contains helper functions for working with memory related information. Registry.h - Contains helper functions for working with Final Fantasy XI\u0026rsquo;s registry information. ScopeGuard.h - Implements a basic scope guard helper to execute functions when leaving a given scope. Threading.h - Implements various thread based objects. (Event, LockableObject, Thread) imgui.h - Exposes ImGui to the plugin SDK, contains and implements the IGuiManager interface for the SDK. Easy Maintenance Within a plugin, it is common to want to make use of game related object information, such as:\nAccessing your party member information. Accessing your own player information. Accessing information about your equipment. Accessing information about your inventory. Accessing information about your current target. etc. The main two methods of doing this are either tracking the information via packets, or reading them from memory. To avoid potential ban issues, Ashita opts to do everything through memory. (Plugins are free to use packets if they wish though.) An issue with plugins using any kind of data like this (memory or packets) is that the game can update and alter the structure of the data. If there are 15 plugins that make use of the inventory structure and the game updates and breaks this structure, then all 15 plugins would require being updated and recompiled to work again.\nTo fix this kind of plugin maintenance nightmare, Ashita has wrapped and implemented custom memory objects around the most commonly used memory structures. Instead of plugins directly accessing the memory objects themselves, they can instead use the wrappers exposed through Ashita\u0026rsquo;s MemoryManager object.\nNow if those same 15 plugins instead make use of the MemoryManager object wrapper for the inventory, if the game updates again and breaks the structure, only Ashita needs to be updated. Once it is, all 15 plugins will continue working as normal without needing to be updated or recompiled.\nPerformance First Ashita aims to be as optimized as possible, putting performance first whenever it can. Our plugin SDK is no exception to this. Plugins are implemented in a manner that is focused on ensuring they do not cause more of an impact on performance than they should.\nPlugins operate mainly through event callbacks. These are exposed to plugins via the IPlugin::HandleXXX calls, that can be overridden. Each of these functions are considered part of a given event category. In order for a plugin to receive a given event, it must tell the core that it uses that event via the return value it gives within the IPlugin::GetFlags function.\nTo help keep performance high, plugins should only ever request events they actually use. For example, if your plugin does not use either packet event, then don\u0026rsquo;t return Ashita::PluginFlags::UsePackets as part of your plugins flags.\nPlugin Arguments When a plugin is loaded, it is passed the entire command line that was passed to load it. This allows plugins to react to specific parameters when being loaded or require some bit of information before being loaded. While not encouraged, as an example, you could use this as a means of locking your plugin behind a password.\nPOL Plugins While normal plugins have been a normal feature of Ashita since the start, v4 has introduced a new kind of plugin, called POL Plugins. These are special plugins that are loaded immediately when Ashita is first injected into PlayOnline (or the given boot loader). These allow a developer to target PlayOnline specific tasks or just access a lower level means of interacting with the client in general.\nAn example use of this new plugin system is the new v4 plugin, Sandbox. (See further below for more information.)\nLike normal plugins, POL Plugins inherit from a base object, to be properly implemented. This time being IPolPlugin instead of IPlugin.\nDue to when they are loaded, POL Plugins have less access to various events and must be coded with a bit more care to prevent crashes. Because they are loaded right at the launch of the client, many of Ashita\u0026rsquo;s objects are not created/initialized yet.\nInternal DAT Parsing (ResourceManager) In order to make use of various game related information, Ashita includes its own internal DAT parser system. This includes the ability to read several types of the games resources that are stored within the DAT files found within the various ROM folders and expose the information back to developers.\nThe ResourceManager includes the ability to parse information such as:\nAbility and spell information. Item information. Dialog tables. String tables. Status icons. Developers can then make use of the ResourceManager to lookup and reference this information with the various functions exposed for each type of information.\nAshita comes preconfigured to read most important information that developers would want access to. This includes the following:\n(strings) Ability Names (strings) Ability Descriptions (strings) Spell Names (strings) Spell Descriptions (spdata) Ability and Spell Information (ie. Mana/TP cost, valid targets, ranges, level requirements, etc.) (status icons) Status Icon Information (Icon image, cancel flag, hidden timer flag, etc.) (strings) Action Messages (strings) Augments (strings) Buff Names (Full and log based names.) (strings) Game Command Help (strings) Game Weekdays (strings) Game Directions (strings) Emotes (strings) Equipment Slot Names (strings) Equipment Slot Names (old) (strings) Job Points (strings) Job Points (Gifts) (strings) Job Names (strings) Job Names (Abbreviations) (strings) Key Item Names (Full and plural.) (strings) Key Item Descriptions (strings) Merits (strings) Monster Ability Names (strings) Monster Groups (Full and plural.) (strings) Moon Phases (strings) Mount Names (strings) Mount Descriptions (strings) Race Names (strings) Region Names (strings) Titles (strings) Weather Names (strings) Weather Effect Names (strings) Zone Names (strings) Zone Names (Abbreviations) (strings) Zone Names (Search Abbreviations) (items) Armor (items) Currency (items) General (items) Instinct (items) Monstrosity (items) Puppet (items) Slips (items) Usable (items) Weapons "},{"uri":"http://docs.ashitaxi.com/requirements/","title":"System Requirements","tags":[],"description":"","content":"\nIn order to make use of Ashita, there are some requirements you will need to install. While some of these are optional, it is suggested to install everything listed on this page to ensure anything you may use with Ashita, or additional third-party tooling, works without dependency issues.\nSupported Operating Systems Ashita supports the following operating systems:\nWindows 7 (Must install latest service packs.) Windows 8, Windows 8.1 Windows 10 Windows 11 While Ashita may work on other operating systems not listed above, we do not give any kind of direct support for them!\nGame Client Due to how changes can happen with the game client, not all client versions are supported. Ashita v4 targets the latest retail client, but can work with older clients.\nThe current release of Ashita v4 requires, at minimum, the following client version (or newer) in order to fully work properly: Nov. 10, 2021\nGame Requirements In order to launch and play Final Fantasy XI itself, you must have the following installed:\nDownload - DirectX Runtime (June 2010) Enabling DirectPlay Final Fantasy XI makes use of DirectPlay as well and on newer operating systems (Windows 8 and newer) you may need to manually enable this feature. You can enable this via the following steps:\nPress the Windows key on your keyboard or manually open the start bar. Type Control Panel and select Control Panel from the list of results to open. Depending on the view displayed, click the following button: Programs -\u0026gt; Uninstall a Program Programs \u0026amp; Features On the left side bar, click the Turn Windows features on or off . Locate Legacy Components and expand it to reveal its additional options. Check DirectPlay in the list. Click Ok to save the changes. .NET Frameworks Ashita, and many other third-party tools, makes use of the .NET Framework from Microsoft. There are several versions of the framework that you may want to install to best support as many tools as possible. We mainly recommend installing the following versions:\nDownload - .NET Framework 4.0 Download - .NET Framework 4.5.2 Download - .NET Framework 4.8 Download - .NET Framework 4.8.1 Microsoft VC++ Redistributables Ashita is developed and compiled on Windows using Microsoft Visual Studio 2022. Because of this, users will need to install the below VC++ Redist. packages. The latest package is required for Ashita, however you may want to install the previous versions as well to ensure the best compatibility with all other third-party tools and third-party plugins.\nRequired:\nDownload - VC++ Redist. 2015, 2017, 2019, 2022 Optional (but recommended):\nDownload - VC++ Redist. 2005 SP1 Download - VC++ Redist. 2008 SP1 Download - VC++ Redist. 2010 SP1 Download - VC++ Redist. 2012 Update 4 Download - VC++ Redist. 2013 "},{"uri":"http://docs.ashitaxi.com/installation/","title":"Installing Ashita","tags":[],"description":"","content":"\nThis page is subject to change heavily in the future when Ashita v4 gains its full UI launcher.\nBeta Installation Currently, Ashita v4 is in open beta testing. Due to this, we do not have a full GUI launcher available yet which would normally handle automatically updating and installing missing files. During this time, you will need to manually download and update your Ashita v4 installation.\nWe currently host the latest beta releases and updates on GitHub here: https://github.com/AshitaXI/Ashita-v4beta\nDownloading You can download a full snapshot of the current beta release here: https://github.com/AshitaXI/Ashita-v4beta/archive/refs/heads/main.zip\nInstalling We DO NOT recommend installing Ashita, or any third-party tool, inside of any system folders.\nYou should not install third-party tools into Program Files or Program Files (x86)!\nOnce downloaded, extract the zip contents to a new folder, we recommend C:\\Ashita\\ to avoid issues with protected/system folders.\nConfigurations Ashita stores its boot configurations / profiles within its /config/boot/ folder. Each character you wish to play on can have its own profile, or you can use a single general profile for all characters. You will find example configuration files in this folder.\nexample-privateserver.ini - Demonstrates configurations needed in order to launch Ashita for private servers. example-retail.ini - Demonstrates configurations needed in order to launch Ashita for retail servers. example.ini - General example configuration with no specific purpose enabled. (Will not launch as-is.) These configuration files are heavily commented to help users understand how to change things manually.\nOnce a full launcher is released, it will include a full configuration editor so you will not need to manually edit these files!\nLaunching Currently, the beta version of Ashita is launched through its included command line injector (ashita-cli.exe). You can either create a shortcut to this program or manually run it from the command line. (Note: You will need to run this application as Administrator!)\nThe program takes a single argument which is the name of the configuration file you are trying to boot. It is the name of the file found within the /config/boot/ folder.\nFor example, if you wanted to boot the example-privateserver.ini file, then you would run the program as: ashita-cli.exe example-privateserver.ini\nOr, if you are creating a shortcut, simply edit the shortcut and change the Target path to include the configuration file at the end.\nFor example, your target path would look something like this: C:\\Ashita\\Ashita-cli.exe example-privateserver.ini\n"},{"uri":"http://docs.ashitaxi.com/commands/","title":"In-Game Commands","tags":[],"description":"","content":"\nAshita comes with several built-in commands which are used to interact with and configure it.\nThis page covers the included commands and how to use them.\nThis page does not contain commands implemented via any addons or plugins. Only commands built into the core are listed on this page.\nCommand Syntax Commands implemented within Ashita should (mostly) all follow the below format for their arguments. This helps keep usage unified across all commands. It also makes documentation easier to follow when all commands make use of the same format.\nSyntax Description text Required; entered as shown. \u0026lt;text\u0026gt; Required argument. \u0026lt;text...\u0026gt; Required argument. (Multiple arguments accepted.) (text|text) Required, one of. [text] Optional argument. [text...] Optional argument. (Multiple arguments accepted.) Note: Arguments surrounded with \u0026lt; and \u0026gt; are considered positional, meaning their order matters.\nCategory: Ashita Related Command: /about /about Toggles displaying the Ashita about/credits information. Command: /ashita /ashita Toggles displaying the Ashita sidebar. Command: /aver, /aversion, /ashitaversion /aver /aversion /ashitaversion Prints the current Ashita version information to the chat window. Category: General Command: /paste /paste Pastes the current clipboard text to the chat input. Command: /exit, /terminate /exit /terminate Closes the game client, by force._ This does not gracefully close the game client, it is shut down by force. Settings may be lost while using these commands!\nCategory: Scripts Command: /exec /exec \u0026lt;name\u0026gt; [args...] Executes the given script file. Command: /execstr /execstr \u0026lt;string\u0026gt; [args...] Executes the given script string. Command: /pause, /sleep, /wait /pause [delay] /sleep [delay] /wait [delay] Suspends a script for an amount of time. (Default is 1 second if no delay is given.) This command is not intended to be used outside of scripts! It will freeze the game client if you use it elsewhere.\nCategory: Plugins Command: /plugins /plugins info \u0026lt;name\u0026gt; Displays detailed information about a given loaded plugin. /plugins link \u0026lt;name\u0026gt; Opens the given plugins link in the systems default browser. /plugins list Opens a UI window displaying a list of plugins. (Not yet implemented.) /plugins silent [0 | 1] Toggles, or sets, if plugin commands should print messages to the chat window. Command: /load /load \u0026lt;name\u0026gt; [args...] Loads the given plugin. Command: /unload /unload \u0026lt;name\u0026gt; Unloads the given plugin. Command: /unloadall /unloadall Unloads all currently loaded plugins. Command: /list /list Lists all loaded plugins. Category: Alias \u0026amp; Binds Command: /alias /alias add \u0026lt;trigger\u0026gt; \u0026lt;command\u0026gt; /alias \u0026lt;trigger\u0026gt; \u0026lt;command\u0026gt; Adds an alias with the given trigger. /alias clear Clears the list of registered aliases. /alias (del | delete) Deletes an alias. /alias list Lists the current registered aliases. Command: /bind /bind block [0 | 1] Toggles, or sets, blocking keybinds while game input is open. /bind list Lists the current registered keybinds. /bind silent [0 | 1] Toggles, or sets, if keybind commands should output messages to the chat window. /bind [!^@#+]\u0026lt;key\u0026gt; [down | up] \u0026lt;command\u0026gt; Binds a key combination to the given command. Keybinds make use of the !^@#+ characters as modifiers. These characters represent:\n! - Modifier symbol for the ALT key. # - Modifier symbol for the APPS key. ^ - Modifier symbol for the CTRL key. + - Modifier symbol for the SHIFT key. @ - Modifier symbol for the WIN key. Command: /unbind /unbind all Unbinds all registered keybinds. /unbind [!^@#+]\u0026lt;key\u0026gt; [down | up] Unbinds a key combination. Category: Input Devices Command: /controller, /gamepad /controller (allowbackground | allowbg | bg) [0 | 1] /gamepad (allowbackground | allowbg | bg) [0 | 1] Toggles, or sets, if the gamepad should be accessible while the game is not in focus. /controller disable [0 | 1] /gamepad disable [0 | 1] Toggles, or sets, if the gamepad should be ignored/disabled. If you do not use a control while playing, it is recommended to fully disable the gamepad to fix a potential micro-stutter the game will have.\nYou can use the /gamepad disable command to fix this problem.\nCommand: /keyboard /keyboard winkey [0 | 1] Toggles, or sets, if the Windows key is enabled. Command: /mouse /mouse block [0 | 1] Toggles, or sets, if the mouse should be blocked from sending input to the game. /mouse unhook [0 | 1] Toggles, or sets, if the mouse should be unhooked from window snapping. Category: Direct3D Command: /ambient /ambient Toggles the ambient lighting feature. /ambient [0 | 1] Sets, or toggles, the ambient lighting feature off or on. /ambient \u0026lt;r\u0026gt; \u0026lt;g\u0026gt; \u0026lt;b\u0026gt; Sets the ambient lighting color. Command: /fillmode /fillmode Toggles the fillmode setting between solid and wireframe. /fillmode [value] Sets the fillmode to the given value. Valid fill mode values are:\n1 - Point 2 - Wireframe 3 - Solid Category: Addons These commands require the Addons plugin to be loaded in order for them to work!\nCommand: /addon /addon silent [0 | 1] Toggles, or sets, if addon commands should print messages to the chat window. /addon load \u0026lt;name\u0026gt; Loads the given addon. /addon unload \u0026lt;name\u0026gt; Unloads the given addon. /addon unloadall Unloads all currently loaded addons. /addon kill \u0026lt;name\u0026gt; Kills the given addon. /addon reload \u0026lt;name\u0026gt; Reloads the given addon. /addon exec \u0026lt;name\u0026gt; \u0026lt;str\u0026gt; Executes a string of Lua code within the given addons state. /addon list Lists all loaded addons. /addon info \u0026lt;name\u0026gt; Displays detailed information about a given loaded addon. /addon link \u0026lt;name\u0026gt; Opens the given addons link in the systems default browser. "},{"uri":"http://docs.ashitaxi.com/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://docs.ashitaxi.com/credits/","title":"Credits","tags":[],"description":"","content":"Ashita is developed with ❤️ by its core development team, and greatly enhanced by its various plugin and addon developers.\nBelow are lists of credits and shoutouts to the various people who have brought Ashita to life and continue its development.\nTooling Ashita is developed using the following tooling:\nVisual Studio 2022 Visual Studio Code Insiders GitHub The following extensions are used with Visual Studio Code:\nC/C++ (Microsoft) CMake (twxs) CMake Tools (Microsoft) Even Better TOML (tamasfe) Instant Markdown (David Bankier) Lipsum Generator (Nino Maruszewski) Lua (sumneko) Lua Debug (actboy168) Third-Party Libraries Ashita is developed using the following thirdparty libraries:\nMicrosoft Detours: https://github.com/microsoft/Detours (API and function hooking.) ImGui: https://github.com/ocornut/imgui (Custom in-game gui.) MoonJIT: https://github.com/moonjit/moonjit (Lua scripting engine for addons.) lstruct: http://www.inf.puc-rio.br/~roberto/struct/ (Lua extension for binary data reading/writing.) luasocket: https://github.com/lunarmodules/luasocket (Lua extension for web sockets and requests.) luasec: https://github.com/brunoos/luasec (Lua extension for HTTPS sockets and requests.) openssl: https://github.com/openssl/openssl (Library used for SSL.) sol3: https://github.com/ThePhD/sol2 (Lua wrapper library.) tsl: https://github.com/Tessil/ordered-map (Better map implementation.) vld: https://github.com/AshitaXI/vld (Debug mode leak detections. Credit to VLD Team, fork and adjustments by Ashita for VS2022.) List.h: (Better linked list implementation, credit to Patrick Wyatt.) Sugar Library Credits The Sugar Lua library is made by atom0s and is inspired by similar functional programming libraries for Lua:\nMetatable Abuse http://lua-users.org/wiki/MethodChainingWrapper https://gist.github.com/gvx/2277797 https://gist.github.com/remyroez/baa67504e7fcdea405465b2f5a68b0b3 https://stackoverflow.com/a/33990997 Functional Lua https://github.com/lunarmodules/Penlight https://github.com/stevedonovan/Microlight https://github.com/luafun/luafun https://github.com/Yonaba/Moses https://github.com/mirven/underscore.lua https://github.com/siffiejoe/lua-fx With additional inspiration from other language projects such as: Underscore.js, Lodash.js, Ramda.js, Sugar.js, Mout.js, Rx.js Misc References https://github.com/lua-nucleo/lua-nucleo https://github.com/lua-stdlib/lua-stdlib https://github.com/Yonaba/Allen https://github.com/torch/xlua https://github.com/timruffles/romans https://stackoverflow.com/a/32660766 https://riptutorial.com/lua https://github.com/bjc/prosody/tree/master/util Documentation Credits Hugo - https://gohugo.io/ (Static website generator.) learn: https://learn.netlify.app/en/ (Theme for Hugo.) Other Credits Project Icon (Moogle) - Unknown original creator. If you made the icon we use (found on a free icon website) please let me know who you are to give proper credits! Developers Lead Developers RZN (Retired, original creator of Ashita.) atom0s (Lead Developer) Thorny (aka Lolwutt, Core Contributor) Addon \u0026amp; Plugin Developers (Third-party) Apogee BangPlaysGames, Bambooya, bluekirby0 Drusciliana Farmboy0, Fel (aka zombie343), Flanagak h1pp0, Heals, Hypnotoad Jaza, Julian Lamalas MalRD, matix Nospheratu Praenuntiae Shinzaku, Shiyo (aka ShiyoKozuki), Spiken (aka Spike2D) TheMystic (aka lenonk) Venrell, Vicrelant Xenonsmurf If you have contributed to Ashita, created an addon or plugin that is publicly available, or otherwise feel you should be listed on this page, please contact atom0s#0001 on Discord to be added properly.\n"},{"uri":"http://docs.ashitaxi.com/","title":"Index","tags":[],"description":"","content":"\nAshita Discord Chat GitHub Group Bug Reports Documentation Welcome to the Ashita project documentation website. This site is used to help users of Ashita get familiar with its features, commands, as well as help developers further extend the project via plugins and addons. Please use the sidebar to the left to navigate through the various pages of information, or, use the search bar at the top left to look for a specific bit of information.\nWhat is Ashita? Ashita is a free feature-rich third-party enhancement/modification for the MMORPG, Final Fantasy XI.\nAshita operates by launching and directly injecting itself (Ashita.dll) into the games main process. (Generally pol.exe unless using a modified boot loader for private servers.) Once injected, Ashita will begin applying custom hooks, patches and other modifications to the games memory. These include things like hooking onto the games chat and packet functions, allowing Ashita to see the games chat, commands and other text output along with the incoming and outgoing packets of the game.\nAshita can then further extend the client by adding its own commands, allowing for outputting custom text to the chat, injecting packets to the client and server, and much much more.\n(See the Features page for a full list of Ashita\u0026rsquo;s features.)\nPlayers can also enjoy additional features provided by plugins and addons (via the Addons plugin) which can be loaded within Ashita, directly in-game.\nAshita\u0026rsquo;s History Ashita was originally created, by RZN, on Aug 19, 2011 and was originally named ‘FFACE 5’. The idea was to replace the FFACE project with a full windowing ability and feature set that would replace the traditional FFACE.dll.\nAshita v1 Later, due to major design changes, adjustments and alterations the project was instead separated from the FFACE project and was given its name Ashita on Feb. 20, 2012.\nAround version 1.0.0.10 of Ashita, atom0s had joined the project as a plugin developer with the means of becoming a core developer to help the project grow. After creating several key plugins that users were accustomed to from another project, atom0s began working with RZN on the core. Soon after atom0s became a core/lead developer with RZN on the whole project.\nAshita underwent lots of changes and improvements and partial rewrites of various parts of the core. Soon after, the project had grown in popularity and it saw many new third-party plugins from various players alike.\nAshita v2 Due to limitations in how Ashita was currently coded, it was decided that a rewrite would be in the best interest of Ashita. atom0s began development on Ashita v2 shortly after the discussions.\nSoon after, Ashita v2 was beginning beta testing and had its full release in early 2014. Ashita v2 brought many new things to the Ashita project such as:\nMuch cleaner and more optimized code base. Much more flexible plugin system that would prevent plugins from breaking due to core updates. Lots of bug fixes from Ashita v1 that were hard to track down in the old code base. New font object system rewrite to make font objects even more customizable. And much much more! Ashita v3 Ashita v3 was developed to better extend some of the functionality of callbacks to plugins from the core. At the time, v2 had some limitations on what could be done with certain events and it limited the abilities of some major plugins. v3 was discussed between some of the core developers on how to better extend these events and further improve the plugin system. Once some solid ideas were made, work on v3 began. Ashita v3 was started around October 2016 with the hopes to build out an even more enjoyable platform for players.\nDuring the rewrite, atom0s took the time to further improve the core code of the project making it much easier to update various parts of the core for any additional major changes that may come to the project. Another key adjustment made here was the removal of the old AnTweakbar UI system in favor of the newly added ImGui system. This resulted in the project being rewritten rather than being adjusted. With some guidelines in place, atom0s began working on Ashita v3 in his spare time while still focusing on keeping v2 up to date and working properly. Some key points on what were focused on with Ashita v3 were:\nFull rewrite to optimize and modernize the Ashita core. (C++11/14 features, cint types, etc.) Core code cleanup and commenting, now making use of JSDoc style comments across the whole project. Enhanced plugin system with better callbacks for things such as the packet handlers and similar. Added and improved callbacks for things such as command handling and incoming/outgoing text. Exposure of more Direct3D calls that are commonly used in hacks/cheats to assist with various things. Removal of old unused things such as AnTweakBar UI system, which has been succeeded by the newer ImGui UI system. Massive overhaul and cleanup of the plugin SDK (known as the ADK). And much more! A full list of changes during this time were kept over on the forums here: https://forums.ashitaxi.com/viewtopic.php?f=15\u0026amp;t=66\nAshita v3 is considered end of life and feature-complete as of 2022.\nAshita v4 During the year 2018, internal discussions of how to improve parts of Ashita began. These discussions covered various aspects of things that were seen as shortcomings or means to better the project as a whole to add new features. While some discussions did turn into features added to the current v3 project, more larger scale changes or ideas were kept on hold for the potential future v4 project.\nWhile some larger idea testing began towards the end of 2019, the more main focused development of v4 began in 2020.\nDue to the larger scale goals and changes with the new ideas for v4, a full rewrite was again considered the best plan of action. However, larger portions of v3\u0026rsquo;s current codebase could be easily reused while still focusing on refreshing different parts of the code that needed adjustments.\nAshita v4 entered semi-public beta testing on May 24th, 2020 via a Discord announcement seeking testers. Then, shortly after, on June 13th, 2020 public beta testing started.\nAs of the writing of this documentation, Ashita v4 is still in beta testing.\n"},{"uri":"http://docs.ashitaxi.com/tags/","title":"Tags","tags":[],"description":"","content":""}]